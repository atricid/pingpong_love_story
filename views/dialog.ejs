<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Pong Love Story</title>
    <script src="https://pixijs.download/release/pixi.js"></script>

    <link rel="stylesheet" type="text/css" href="/css/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Klee+One&display=swap" rel="stylesheet">
</head>

<body>
    <div class="top-nav">
        <a href="/">Ping Pong Love Story</a>
    </div>

    <!-- Game container placed in here with script -->
    <div class="game-container">
    </div>
    <script type="module">
        const mainCharacter = "Pong-Chan";
        const blackPaddle = "blackPaddle";
        const redPaddle = "redPaddle";

        const story = [
            {
                speaker: blackPaddle,
                dialog: "Hi, " + mainCharacter, answers: [
                    { option: "Hi", next: "greet_normal" },
                    { option: "...", next: "greet_ignore" },
                ]
            },


            { label: "greet_normal", speaker: blackPaddle, dialog: "I am happy you like my game!", next: "like_end", answers: [{option:'...', next:"greet_end"}]},
            { label: "greet_ignore", speaker: blackPaddle, dialog: "You made me sad!", next: "like_end", answers: [{option:'...', next:"greet_end"}]},
            { label: "greet_end", speaker: blackPaddle, dialog: "....", next: "like_end", answers: [{option:'...', next:"greet_end"}]}
        ];

        // Create the application helper and add its render target to the page
        // setup
        const app = new PIXI.Application();
        const Assets = PIXI.Assets;
        const Graphics = PIXI.Graphics;
        const Text = PIXI.Text;
        const containerWidth = 640;
        const containerHeight = 480;
        await app.init({ width: containerWidth, height: containerHeight })
        let gameContainer = document.querySelector('.game-container');
        gameContainer.appendChild(app.canvas);

        const primaryColor = '#FB6F92';
        const secondaryColor = '#FF8FAB';
        const backgroundColor = '#FFC2D1';
        const buttonColor = '#FB6F92'

        app.renderer.background.color = backgroundColor;

        let header = new Graphics()
            .rect(0, 0, containerWidth, 50)
            .fill(primaryColor);
        app.stage.addChild(header);

        let chapterText = new Text({
            text: 'Chapter 1',
            style: {
                fontFamily: 'Klee One',
                fontSize: 24,
                fill: 'FFF',
                align: 'center',
            },
            position: { x: containerWidth / 2 - 9 * 6, y: 50 / 2 - 12 } // height of header / 2 - font size / 2, to center text
        })
        app.stage.addChild(chapterText);

        await PIXI.Assets.load('/assets/bunny.jpg');
        let sprite = PIXI.Sprite.from('/assets/bunny.jpg');

        let currentLine = 0
        execute_game();
        
        // https://gamedev.stackexchange.com/questions/54238/how-do-i-implement-branching-dialogue-in-javascript
        function execute_game() {
            //Start the game
            renderDialog(story[currentLine].speaker, story[currentLine].dialog, story[currentLine].answers);
        }

        // rerenders the page, when button is clicked
        function handleAnswerClick(nextLabel) {
            const nextNode = findStoryNode(nextLabel);
            if (nextNode) {
                renderDialog(nextNode.speaker ,nextNode.dialog, nextNode.answers);
            } else {
                console.error(`Node with label ${nextLabel} not found`);
            }
        }
        
        // finds the corresponding node to render
        function findStoryNode(nextLabel) {
            return story.find(node => node.label === nextLabel);
        }

        // renders dialog based off of node
        function renderDialog(speaker, dialog, answers) {
            // Create the sprite and add it to the stage
            sprite.position.set(100, 100);
            app.stage.addChild(sprite);

            let bottomDiv = new Graphics()
                .rect(0, 300, containerWidth, containerHeight - 300)
                .fill(secondaryColor)
            app.stage.addChild(bottomDiv);

            let speakerPixi = new Text({
                text: speaker,
                style: {
                    fontFamily: 'Klee One',
                    fontSize: 24,
                    fill: 'FFF',
                },
                position: { x: containerWidth / 8, y: 320 }
            })
            app.stage.addChild(speakerPixi);

            let dialogPixi = new PIXI.Text({
                text: wrapText(dialog, 40),
                style: {
                    fontFamily: 'Klee One',
                    fontSize: 20,
                    fill: 'FFF',
                },
                align: 'left',
                maxWidth: containerWidth - 200,
                position: { x: containerWidth / 8, y: 350 },
            })
            app.stage.addChild(dialogPixi);

            // Add a ticker callback to move the sprite back and forth
            let elapsed = 0.0;

            app.ticker.add((ticker) => {
                elapsed += ticker.deltaTime;
                sprite.y = containerHeight/6 + Math.cos(elapsed / 50.0) * 10.0;
            });

            const margin = 10
            const buttonWidth = 150
            const buttonHeight = 45
            // Usage:
            answers.forEach((option, index) => {
                let buttonXPosition = containerWidth - 170;
                let buttonYPosition = containerHeight - 170 + (index * (margin + buttonHeight));
                createButton(option.option, buttonWidth, buttonHeight, buttonXPosition, buttonYPosition, () => {
                    return handleAnswerClick(option.next);
                    // Handle button click logic here
                });
            });

        }
        //Helper function used to wrap text
        // Given text, and character limit per line, return string that wraps accordinglyg
        function wrapText(text, widthLimit) {
            let wrappedText = '';
            let words = text.split(' ');
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                let word = words[i];
                let potentialLine = currentLine + word;

                if (potentialLine.length <= widthLimit) {
                    currentLine = potentialLine + ' ';
                } else {
                    wrappedText += currentLine.trim() + '\n';
                    currentLine = word + ' ';
                }
            }

            wrappedText += currentLine.trim();
            return wrappedText;
        }

        // Create the button
        function createButton(text, width, height, x, y, callback) {
            let button = new PIXI.Graphics()
                .rect(x, y, width, height)
                .fill(buttonColor);

            let buttonText = new PIXI.Text({
                text: text,
                style: {
                    fontFamily: 'Klee One',
                    fontSize: 24,
                    fill: 'FFF',
                },
                position: { x: button.bounds.x + text.length * 2, y: button.bounds.y + 12 },
            });

            app.stage.addChild(button);
            app.stage.addChild(buttonText);

            button.interactive = true;
            button.buttonMode = true;
            button.on('pointerdown', callback);
        }

    </script>

</body>

</html>